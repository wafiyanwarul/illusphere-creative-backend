
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ProjectActivity` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model ProjectActivity
 * 
 */
export type ProjectActivityModel = runtime.Types.Result.DefaultSelection<Prisma.$ProjectActivityPayload>

export type AggregateProjectActivity = {
  _count: ProjectActivityCountAggregateOutputType | null
  _min: ProjectActivityMinAggregateOutputType | null
  _max: ProjectActivityMaxAggregateOutputType | null
}

export type ProjectActivityMinAggregateOutputType = {
  id: string | null
  projectId: string | null
  userId: string | null
  type: $Enums.ActivityType | null
  action: string | null
  description: string | null
  createdAt: Date | null
}

export type ProjectActivityMaxAggregateOutputType = {
  id: string | null
  projectId: string | null
  userId: string | null
  type: $Enums.ActivityType | null
  action: string | null
  description: string | null
  createdAt: Date | null
}

export type ProjectActivityCountAggregateOutputType = {
  id: number
  projectId: number
  userId: number
  type: number
  action: number
  description: number
  metadata: number
  createdAt: number
  _all: number
}


export type ProjectActivityMinAggregateInputType = {
  id?: true
  projectId?: true
  userId?: true
  type?: true
  action?: true
  description?: true
  createdAt?: true
}

export type ProjectActivityMaxAggregateInputType = {
  id?: true
  projectId?: true
  userId?: true
  type?: true
  action?: true
  description?: true
  createdAt?: true
}

export type ProjectActivityCountAggregateInputType = {
  id?: true
  projectId?: true
  userId?: true
  type?: true
  action?: true
  description?: true
  metadata?: true
  createdAt?: true
  _all?: true
}

export type ProjectActivityAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProjectActivity to aggregate.
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProjectActivities to fetch.
   */
  orderBy?: Prisma.ProjectActivityOrderByWithRelationInput | Prisma.ProjectActivityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProjectActivityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProjectActivities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProjectActivities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ProjectActivities
  **/
  _count?: true | ProjectActivityCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProjectActivityMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProjectActivityMaxAggregateInputType
}

export type GetProjectActivityAggregateType<T extends ProjectActivityAggregateArgs> = {
      [P in keyof T & keyof AggregateProjectActivity]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProjectActivity[P]>
    : Prisma.GetScalarType<T[P], AggregateProjectActivity[P]>
}




export type ProjectActivityGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProjectActivityWhereInput
  orderBy?: Prisma.ProjectActivityOrderByWithAggregationInput | Prisma.ProjectActivityOrderByWithAggregationInput[]
  by: Prisma.ProjectActivityScalarFieldEnum[] | Prisma.ProjectActivityScalarFieldEnum
  having?: Prisma.ProjectActivityScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProjectActivityCountAggregateInputType | true
  _min?: ProjectActivityMinAggregateInputType
  _max?: ProjectActivityMaxAggregateInputType
}

export type ProjectActivityGroupByOutputType = {
  id: string
  projectId: string
  userId: string | null
  type: $Enums.ActivityType
  action: string
  description: string | null
  metadata: runtime.JsonValue | null
  createdAt: Date
  _count: ProjectActivityCountAggregateOutputType | null
  _min: ProjectActivityMinAggregateOutputType | null
  _max: ProjectActivityMaxAggregateOutputType | null
}

type GetProjectActivityGroupByPayload<T extends ProjectActivityGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProjectActivityGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProjectActivityGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProjectActivityGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProjectActivityGroupByOutputType[P]>
      }
    >
  >



export type ProjectActivityWhereInput = {
  AND?: Prisma.ProjectActivityWhereInput | Prisma.ProjectActivityWhereInput[]
  OR?: Prisma.ProjectActivityWhereInput[]
  NOT?: Prisma.ProjectActivityWhereInput | Prisma.ProjectActivityWhereInput[]
  id?: Prisma.StringFilter<"ProjectActivity"> | string
  projectId?: Prisma.StringFilter<"ProjectActivity"> | string
  userId?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  type?: Prisma.EnumActivityTypeFilter<"ProjectActivity"> | $Enums.ActivityType
  action?: Prisma.StringFilter<"ProjectActivity"> | string
  description?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  metadata?: Prisma.JsonNullableFilter<"ProjectActivity">
  createdAt?: Prisma.DateTimeFilter<"ProjectActivity"> | Date | string
  project?: Prisma.XOR<Prisma.ProjectScalarRelationFilter, Prisma.ProjectWhereInput>
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}

export type ProjectActivityOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  type?: Prisma.SortOrder
  action?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  metadata?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  project?: Prisma.ProjectOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
}

export type ProjectActivityWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.ProjectActivityWhereInput | Prisma.ProjectActivityWhereInput[]
  OR?: Prisma.ProjectActivityWhereInput[]
  NOT?: Prisma.ProjectActivityWhereInput | Prisma.ProjectActivityWhereInput[]
  projectId?: Prisma.StringFilter<"ProjectActivity"> | string
  userId?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  type?: Prisma.EnumActivityTypeFilter<"ProjectActivity"> | $Enums.ActivityType
  action?: Prisma.StringFilter<"ProjectActivity"> | string
  description?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  metadata?: Prisma.JsonNullableFilter<"ProjectActivity">
  createdAt?: Prisma.DateTimeFilter<"ProjectActivity"> | Date | string
  project?: Prisma.XOR<Prisma.ProjectScalarRelationFilter, Prisma.ProjectWhereInput>
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}, "id">

export type ProjectActivityOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  type?: Prisma.SortOrder
  action?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  metadata?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.ProjectActivityCountOrderByAggregateInput
  _max?: Prisma.ProjectActivityMaxOrderByAggregateInput
  _min?: Prisma.ProjectActivityMinOrderByAggregateInput
}

export type ProjectActivityScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProjectActivityScalarWhereWithAggregatesInput | Prisma.ProjectActivityScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProjectActivityScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProjectActivityScalarWhereWithAggregatesInput | Prisma.ProjectActivityScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"ProjectActivity"> | string
  projectId?: Prisma.StringWithAggregatesFilter<"ProjectActivity"> | string
  userId?: Prisma.StringNullableWithAggregatesFilter<"ProjectActivity"> | string | null
  type?: Prisma.EnumActivityTypeWithAggregatesFilter<"ProjectActivity"> | $Enums.ActivityType
  action?: Prisma.StringWithAggregatesFilter<"ProjectActivity"> | string
  description?: Prisma.StringNullableWithAggregatesFilter<"ProjectActivity"> | string | null
  metadata?: Prisma.JsonNullableWithAggregatesFilter<"ProjectActivity">
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"ProjectActivity"> | Date | string
}

export type ProjectActivityCreateInput = {
  id?: string
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutActivitiesInput
  user?: Prisma.UserCreateNestedOneWithoutActivitiesInput
}

export type ProjectActivityUncheckedCreateInput = {
  id?: string
  projectId: string
  userId?: string | null
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutActivitiesNestedInput
  user?: Prisma.UserUpdateOneWithoutActivitiesNestedInput
}

export type ProjectActivityUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityCreateManyInput = {
  id?: string
  projectId: string
  userId?: string | null
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityListRelationFilter = {
  every?: Prisma.ProjectActivityWhereInput
  some?: Prisma.ProjectActivityWhereInput
  none?: Prisma.ProjectActivityWhereInput
}

export type ProjectActivityOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProjectActivityCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  action?: Prisma.SortOrder
  description?: Prisma.SortOrder
  metadata?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectActivityMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  action?: Prisma.SortOrder
  description?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectActivityMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  projectId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  action?: Prisma.SortOrder
  description?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectActivityCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput> | Prisma.ProjectActivityCreateWithoutUserInput[] | Prisma.ProjectActivityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutUserInput | Prisma.ProjectActivityCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ProjectActivityCreateManyUserInputEnvelope
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
}

export type ProjectActivityUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput> | Prisma.ProjectActivityCreateWithoutUserInput[] | Prisma.ProjectActivityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutUserInput | Prisma.ProjectActivityCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ProjectActivityCreateManyUserInputEnvelope
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
}

export type ProjectActivityUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput> | Prisma.ProjectActivityCreateWithoutUserInput[] | Prisma.ProjectActivityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutUserInput | Prisma.ProjectActivityCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ProjectActivityUpsertWithWhereUniqueWithoutUserInput | Prisma.ProjectActivityUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ProjectActivityCreateManyUserInputEnvelope
  set?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  disconnect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  delete?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  update?: Prisma.ProjectActivityUpdateWithWhereUniqueWithoutUserInput | Prisma.ProjectActivityUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ProjectActivityUpdateManyWithWhereWithoutUserInput | Prisma.ProjectActivityUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
}

export type ProjectActivityUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput> | Prisma.ProjectActivityCreateWithoutUserInput[] | Prisma.ProjectActivityUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutUserInput | Prisma.ProjectActivityCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ProjectActivityUpsertWithWhereUniqueWithoutUserInput | Prisma.ProjectActivityUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ProjectActivityCreateManyUserInputEnvelope
  set?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  disconnect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  delete?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  update?: Prisma.ProjectActivityUpdateWithWhereUniqueWithoutUserInput | Prisma.ProjectActivityUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ProjectActivityUpdateManyWithWhereWithoutUserInput | Prisma.ProjectActivityUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
}

export type ProjectActivityCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput> | Prisma.ProjectActivityCreateWithoutProjectInput[] | Prisma.ProjectActivityUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutProjectInput | Prisma.ProjectActivityCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.ProjectActivityCreateManyProjectInputEnvelope
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
}

export type ProjectActivityUncheckedCreateNestedManyWithoutProjectInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput> | Prisma.ProjectActivityCreateWithoutProjectInput[] | Prisma.ProjectActivityUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutProjectInput | Prisma.ProjectActivityCreateOrConnectWithoutProjectInput[]
  createMany?: Prisma.ProjectActivityCreateManyProjectInputEnvelope
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
}

export type ProjectActivityUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput> | Prisma.ProjectActivityCreateWithoutProjectInput[] | Prisma.ProjectActivityUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutProjectInput | Prisma.ProjectActivityCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.ProjectActivityUpsertWithWhereUniqueWithoutProjectInput | Prisma.ProjectActivityUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.ProjectActivityCreateManyProjectInputEnvelope
  set?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  disconnect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  delete?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  update?: Prisma.ProjectActivityUpdateWithWhereUniqueWithoutProjectInput | Prisma.ProjectActivityUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.ProjectActivityUpdateManyWithWhereWithoutProjectInput | Prisma.ProjectActivityUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
}

export type ProjectActivityUncheckedUpdateManyWithoutProjectNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput> | Prisma.ProjectActivityCreateWithoutProjectInput[] | Prisma.ProjectActivityUncheckedCreateWithoutProjectInput[]
  connectOrCreate?: Prisma.ProjectActivityCreateOrConnectWithoutProjectInput | Prisma.ProjectActivityCreateOrConnectWithoutProjectInput[]
  upsert?: Prisma.ProjectActivityUpsertWithWhereUniqueWithoutProjectInput | Prisma.ProjectActivityUpsertWithWhereUniqueWithoutProjectInput[]
  createMany?: Prisma.ProjectActivityCreateManyProjectInputEnvelope
  set?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  disconnect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  delete?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  connect?: Prisma.ProjectActivityWhereUniqueInput | Prisma.ProjectActivityWhereUniqueInput[]
  update?: Prisma.ProjectActivityUpdateWithWhereUniqueWithoutProjectInput | Prisma.ProjectActivityUpdateWithWhereUniqueWithoutProjectInput[]
  updateMany?: Prisma.ProjectActivityUpdateManyWithWhereWithoutProjectInput | Prisma.ProjectActivityUpdateManyWithWhereWithoutProjectInput[]
  deleteMany?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
}

export type EnumActivityTypeFieldUpdateOperationsInput = {
  set?: $Enums.ActivityType
}

export type ProjectActivityCreateWithoutUserInput = {
  id?: string
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  project: Prisma.ProjectCreateNestedOneWithoutActivitiesInput
}

export type ProjectActivityUncheckedCreateWithoutUserInput = {
  id?: string
  projectId: string
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityCreateOrConnectWithoutUserInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  create: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput>
}

export type ProjectActivityCreateManyUserInputEnvelope = {
  data: Prisma.ProjectActivityCreateManyUserInput | Prisma.ProjectActivityCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type ProjectActivityUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  update: Prisma.XOR<Prisma.ProjectActivityUpdateWithoutUserInput, Prisma.ProjectActivityUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.ProjectActivityCreateWithoutUserInput, Prisma.ProjectActivityUncheckedCreateWithoutUserInput>
}

export type ProjectActivityUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  data: Prisma.XOR<Prisma.ProjectActivityUpdateWithoutUserInput, Prisma.ProjectActivityUncheckedUpdateWithoutUserInput>
}

export type ProjectActivityUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.ProjectActivityScalarWhereInput
  data: Prisma.XOR<Prisma.ProjectActivityUpdateManyMutationInput, Prisma.ProjectActivityUncheckedUpdateManyWithoutUserInput>
}

export type ProjectActivityScalarWhereInput = {
  AND?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
  OR?: Prisma.ProjectActivityScalarWhereInput[]
  NOT?: Prisma.ProjectActivityScalarWhereInput | Prisma.ProjectActivityScalarWhereInput[]
  id?: Prisma.StringFilter<"ProjectActivity"> | string
  projectId?: Prisma.StringFilter<"ProjectActivity"> | string
  userId?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  type?: Prisma.EnumActivityTypeFilter<"ProjectActivity"> | $Enums.ActivityType
  action?: Prisma.StringFilter<"ProjectActivity"> | string
  description?: Prisma.StringNullableFilter<"ProjectActivity"> | string | null
  metadata?: Prisma.JsonNullableFilter<"ProjectActivity">
  createdAt?: Prisma.DateTimeFilter<"ProjectActivity"> | Date | string
}

export type ProjectActivityCreateWithoutProjectInput = {
  id?: string
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  user?: Prisma.UserCreateNestedOneWithoutActivitiesInput
}

export type ProjectActivityUncheckedCreateWithoutProjectInput = {
  id?: string
  userId?: string | null
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityCreateOrConnectWithoutProjectInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  create: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput>
}

export type ProjectActivityCreateManyProjectInputEnvelope = {
  data: Prisma.ProjectActivityCreateManyProjectInput | Prisma.ProjectActivityCreateManyProjectInput[]
  skipDuplicates?: boolean
}

export type ProjectActivityUpsertWithWhereUniqueWithoutProjectInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  update: Prisma.XOR<Prisma.ProjectActivityUpdateWithoutProjectInput, Prisma.ProjectActivityUncheckedUpdateWithoutProjectInput>
  create: Prisma.XOR<Prisma.ProjectActivityCreateWithoutProjectInput, Prisma.ProjectActivityUncheckedCreateWithoutProjectInput>
}

export type ProjectActivityUpdateWithWhereUniqueWithoutProjectInput = {
  where: Prisma.ProjectActivityWhereUniqueInput
  data: Prisma.XOR<Prisma.ProjectActivityUpdateWithoutProjectInput, Prisma.ProjectActivityUncheckedUpdateWithoutProjectInput>
}

export type ProjectActivityUpdateManyWithWhereWithoutProjectInput = {
  where: Prisma.ProjectActivityScalarWhereInput
  data: Prisma.XOR<Prisma.ProjectActivityUpdateManyMutationInput, Prisma.ProjectActivityUncheckedUpdateManyWithoutProjectInput>
}

export type ProjectActivityCreateManyUserInput = {
  id?: string
  projectId: string
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  project?: Prisma.ProjectUpdateOneRequiredWithoutActivitiesNestedInput
}

export type ProjectActivityUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  projectId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityCreateManyProjectInput = {
  id?: string
  userId?: string | null
  type: $Enums.ActivityType
  action: string
  description?: string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type ProjectActivityUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneWithoutActivitiesNestedInput
}

export type ProjectActivityUncheckedUpdateWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectActivityUncheckedUpdateManyWithoutProjectInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  type?: Prisma.EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
  action?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type ProjectActivitySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  userId?: boolean
  type?: boolean
  action?: boolean
  description?: boolean
  metadata?: boolean
  createdAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}, ExtArgs["result"]["projectActivity"]>

export type ProjectActivitySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  userId?: boolean
  type?: boolean
  action?: boolean
  description?: boolean
  metadata?: boolean
  createdAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}, ExtArgs["result"]["projectActivity"]>

export type ProjectActivitySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  projectId?: boolean
  userId?: boolean
  type?: boolean
  action?: boolean
  description?: boolean
  metadata?: boolean
  createdAt?: boolean
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}, ExtArgs["result"]["projectActivity"]>

export type ProjectActivitySelectScalar = {
  id?: boolean
  projectId?: boolean
  userId?: boolean
  type?: boolean
  action?: boolean
  description?: boolean
  metadata?: boolean
  createdAt?: boolean
}

export type ProjectActivityOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "projectId" | "userId" | "type" | "action" | "description" | "metadata" | "createdAt", ExtArgs["result"]["projectActivity"]>
export type ProjectActivityInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}
export type ProjectActivityIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}
export type ProjectActivityIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  project?: boolean | Prisma.ProjectDefaultArgs<ExtArgs>
  user?: boolean | Prisma.ProjectActivity$userArgs<ExtArgs>
}

export type $ProjectActivityPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ProjectActivity"
  objects: {
    project: Prisma.$ProjectPayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    projectId: string
    userId: string | null
    type: $Enums.ActivityType
    action: string
    description: string | null
    metadata: runtime.JsonValue | null
    createdAt: Date
  }, ExtArgs["result"]["projectActivity"]>
  composites: {}
}

export type ProjectActivityGetPayload<S extends boolean | null | undefined | ProjectActivityDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload, S>

export type ProjectActivityCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProjectActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProjectActivityCountAggregateInputType | true
  }

export interface ProjectActivityDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectActivity'], meta: { name: 'ProjectActivity' } }
  /**
   * Find zero or one ProjectActivity that matches the filter.
   * @param {ProjectActivityFindUniqueArgs} args - Arguments to find a ProjectActivity
   * @example
   * // Get one ProjectActivity
   * const projectActivity = await prisma.projectActivity.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProjectActivityFindUniqueArgs>(args: Prisma.SelectSubset<T, ProjectActivityFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ProjectActivity that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProjectActivityFindUniqueOrThrowArgs} args - Arguments to find a ProjectActivity
   * @example
   * // Get one ProjectActivity
   * const projectActivity = await prisma.projectActivity.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProjectActivityFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProjectActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProjectActivity that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityFindFirstArgs} args - Arguments to find a ProjectActivity
   * @example
   * // Get one ProjectActivity
   * const projectActivity = await prisma.projectActivity.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProjectActivityFindFirstArgs>(args?: Prisma.SelectSubset<T, ProjectActivityFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProjectActivity that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityFindFirstOrThrowArgs} args - Arguments to find a ProjectActivity
   * @example
   * // Get one ProjectActivity
   * const projectActivity = await prisma.projectActivity.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProjectActivityFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProjectActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ProjectActivities that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ProjectActivities
   * const projectActivities = await prisma.projectActivity.findMany()
   * 
   * // Get first 10 ProjectActivities
   * const projectActivities = await prisma.projectActivity.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const projectActivityWithIdOnly = await prisma.projectActivity.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ProjectActivityFindManyArgs>(args?: Prisma.SelectSubset<T, ProjectActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ProjectActivity.
   * @param {ProjectActivityCreateArgs} args - Arguments to create a ProjectActivity.
   * @example
   * // Create one ProjectActivity
   * const ProjectActivity = await prisma.projectActivity.create({
   *   data: {
   *     // ... data to create a ProjectActivity
   *   }
   * })
   * 
   */
  create<T extends ProjectActivityCreateArgs>(args: Prisma.SelectSubset<T, ProjectActivityCreateArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ProjectActivities.
   * @param {ProjectActivityCreateManyArgs} args - Arguments to create many ProjectActivities.
   * @example
   * // Create many ProjectActivities
   * const projectActivity = await prisma.projectActivity.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProjectActivityCreateManyArgs>(args?: Prisma.SelectSubset<T, ProjectActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ProjectActivities and returns the data saved in the database.
   * @param {ProjectActivityCreateManyAndReturnArgs} args - Arguments to create many ProjectActivities.
   * @example
   * // Create many ProjectActivities
   * const projectActivity = await prisma.projectActivity.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ProjectActivities and only return the `id`
   * const projectActivityWithIdOnly = await prisma.projectActivity.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProjectActivityCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProjectActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ProjectActivity.
   * @param {ProjectActivityDeleteArgs} args - Arguments to delete one ProjectActivity.
   * @example
   * // Delete one ProjectActivity
   * const ProjectActivity = await prisma.projectActivity.delete({
   *   where: {
   *     // ... filter to delete one ProjectActivity
   *   }
   * })
   * 
   */
  delete<T extends ProjectActivityDeleteArgs>(args: Prisma.SelectSubset<T, ProjectActivityDeleteArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ProjectActivity.
   * @param {ProjectActivityUpdateArgs} args - Arguments to update one ProjectActivity.
   * @example
   * // Update one ProjectActivity
   * const projectActivity = await prisma.projectActivity.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProjectActivityUpdateArgs>(args: Prisma.SelectSubset<T, ProjectActivityUpdateArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ProjectActivities.
   * @param {ProjectActivityDeleteManyArgs} args - Arguments to filter ProjectActivities to delete.
   * @example
   * // Delete a few ProjectActivities
   * const { count } = await prisma.projectActivity.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProjectActivityDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProjectActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProjectActivities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ProjectActivities
   * const projectActivity = await prisma.projectActivity.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProjectActivityUpdateManyArgs>(args: Prisma.SelectSubset<T, ProjectActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProjectActivities and returns the data updated in the database.
   * @param {ProjectActivityUpdateManyAndReturnArgs} args - Arguments to update many ProjectActivities.
   * @example
   * // Update many ProjectActivities
   * const projectActivity = await prisma.projectActivity.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ProjectActivities and only return the `id`
   * const projectActivityWithIdOnly = await prisma.projectActivity.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProjectActivityUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProjectActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ProjectActivity.
   * @param {ProjectActivityUpsertArgs} args - Arguments to update or create a ProjectActivity.
   * @example
   * // Update or create a ProjectActivity
   * const projectActivity = await prisma.projectActivity.upsert({
   *   create: {
   *     // ... data to create a ProjectActivity
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ProjectActivity we want to update
   *   }
   * })
   */
  upsert<T extends ProjectActivityUpsertArgs>(args: Prisma.SelectSubset<T, ProjectActivityUpsertArgs<ExtArgs>>): Prisma.Prisma__ProjectActivityClient<runtime.Types.Result.GetResult<Prisma.$ProjectActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ProjectActivities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityCountArgs} args - Arguments to filter ProjectActivities to count.
   * @example
   * // Count the number of ProjectActivities
   * const count = await prisma.projectActivity.count({
   *   where: {
   *     // ... the filter for the ProjectActivities we want to count
   *   }
   * })
  **/
  count<T extends ProjectActivityCountArgs>(
    args?: Prisma.Subset<T, ProjectActivityCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProjectActivityCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ProjectActivity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProjectActivityAggregateArgs>(args: Prisma.Subset<T, ProjectActivityAggregateArgs>): Prisma.PrismaPromise<GetProjectActivityAggregateType<T>>

  /**
   * Group by ProjectActivity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectActivityGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProjectActivityGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProjectActivityGroupByArgs['orderBy'] }
      : { orderBy?: ProjectActivityGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProjectActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ProjectActivity model
 */
readonly fields: ProjectActivityFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ProjectActivity.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProjectActivityClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  project<T extends Prisma.ProjectDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProjectDefaultArgs<ExtArgs>>): Prisma.Prisma__ProjectClient<runtime.Types.Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.ProjectActivity$userArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProjectActivity$userArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ProjectActivity model
 */
export interface ProjectActivityFieldRefs {
  readonly id: Prisma.FieldRef<"ProjectActivity", 'String'>
  readonly projectId: Prisma.FieldRef<"ProjectActivity", 'String'>
  readonly userId: Prisma.FieldRef<"ProjectActivity", 'String'>
  readonly type: Prisma.FieldRef<"ProjectActivity", 'ActivityType'>
  readonly action: Prisma.FieldRef<"ProjectActivity", 'String'>
  readonly description: Prisma.FieldRef<"ProjectActivity", 'String'>
  readonly metadata: Prisma.FieldRef<"ProjectActivity", 'Json'>
  readonly createdAt: Prisma.FieldRef<"ProjectActivity", 'DateTime'>
}
    

// Custom InputTypes
/**
 * ProjectActivity findUnique
 */
export type ProjectActivityFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter, which ProjectActivity to fetch.
   */
  where: Prisma.ProjectActivityWhereUniqueInput
}

/**
 * ProjectActivity findUniqueOrThrow
 */
export type ProjectActivityFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter, which ProjectActivity to fetch.
   */
  where: Prisma.ProjectActivityWhereUniqueInput
}

/**
 * ProjectActivity findFirst
 */
export type ProjectActivityFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter, which ProjectActivity to fetch.
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProjectActivities to fetch.
   */
  orderBy?: Prisma.ProjectActivityOrderByWithRelationInput | Prisma.ProjectActivityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProjectActivities.
   */
  cursor?: Prisma.ProjectActivityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProjectActivities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProjectActivities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProjectActivities.
   */
  distinct?: Prisma.ProjectActivityScalarFieldEnum | Prisma.ProjectActivityScalarFieldEnum[]
}

/**
 * ProjectActivity findFirstOrThrow
 */
export type ProjectActivityFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter, which ProjectActivity to fetch.
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProjectActivities to fetch.
   */
  orderBy?: Prisma.ProjectActivityOrderByWithRelationInput | Prisma.ProjectActivityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProjectActivities.
   */
  cursor?: Prisma.ProjectActivityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProjectActivities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProjectActivities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProjectActivities.
   */
  distinct?: Prisma.ProjectActivityScalarFieldEnum | Prisma.ProjectActivityScalarFieldEnum[]
}

/**
 * ProjectActivity findMany
 */
export type ProjectActivityFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter, which ProjectActivities to fetch.
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProjectActivities to fetch.
   */
  orderBy?: Prisma.ProjectActivityOrderByWithRelationInput | Prisma.ProjectActivityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ProjectActivities.
   */
  cursor?: Prisma.ProjectActivityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProjectActivities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProjectActivities.
   */
  skip?: number
  distinct?: Prisma.ProjectActivityScalarFieldEnum | Prisma.ProjectActivityScalarFieldEnum[]
}

/**
 * ProjectActivity create
 */
export type ProjectActivityCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * The data needed to create a ProjectActivity.
   */
  data: Prisma.XOR<Prisma.ProjectActivityCreateInput, Prisma.ProjectActivityUncheckedCreateInput>
}

/**
 * ProjectActivity createMany
 */
export type ProjectActivityCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ProjectActivities.
   */
  data: Prisma.ProjectActivityCreateManyInput | Prisma.ProjectActivityCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ProjectActivity createManyAndReturn
 */
export type ProjectActivityCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * The data used to create many ProjectActivities.
   */
  data: Prisma.ProjectActivityCreateManyInput | Prisma.ProjectActivityCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ProjectActivity update
 */
export type ProjectActivityUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * The data needed to update a ProjectActivity.
   */
  data: Prisma.XOR<Prisma.ProjectActivityUpdateInput, Prisma.ProjectActivityUncheckedUpdateInput>
  /**
   * Choose, which ProjectActivity to update.
   */
  where: Prisma.ProjectActivityWhereUniqueInput
}

/**
 * ProjectActivity updateMany
 */
export type ProjectActivityUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ProjectActivities.
   */
  data: Prisma.XOR<Prisma.ProjectActivityUpdateManyMutationInput, Prisma.ProjectActivityUncheckedUpdateManyInput>
  /**
   * Filter which ProjectActivities to update
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * Limit how many ProjectActivities to update.
   */
  limit?: number
}

/**
 * ProjectActivity updateManyAndReturn
 */
export type ProjectActivityUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * The data used to update ProjectActivities.
   */
  data: Prisma.XOR<Prisma.ProjectActivityUpdateManyMutationInput, Prisma.ProjectActivityUncheckedUpdateManyInput>
  /**
   * Filter which ProjectActivities to update
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * Limit how many ProjectActivities to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ProjectActivity upsert
 */
export type ProjectActivityUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * The filter to search for the ProjectActivity to update in case it exists.
   */
  where: Prisma.ProjectActivityWhereUniqueInput
  /**
   * In case the ProjectActivity found by the `where` argument doesn't exist, create a new ProjectActivity with this data.
   */
  create: Prisma.XOR<Prisma.ProjectActivityCreateInput, Prisma.ProjectActivityUncheckedCreateInput>
  /**
   * In case the ProjectActivity was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProjectActivityUpdateInput, Prisma.ProjectActivityUncheckedUpdateInput>
}

/**
 * ProjectActivity delete
 */
export type ProjectActivityDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
  /**
   * Filter which ProjectActivity to delete.
   */
  where: Prisma.ProjectActivityWhereUniqueInput
}

/**
 * ProjectActivity deleteMany
 */
export type ProjectActivityDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProjectActivities to delete
   */
  where?: Prisma.ProjectActivityWhereInput
  /**
   * Limit how many ProjectActivities to delete.
   */
  limit?: number
}

/**
 * ProjectActivity.user
 */
export type ProjectActivity$userArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * ProjectActivity without action
 */
export type ProjectActivityDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProjectActivity
   */
  select?: Prisma.ProjectActivitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProjectActivity
   */
  omit?: Prisma.ProjectActivityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectActivityInclude<ExtArgs> | null
}
